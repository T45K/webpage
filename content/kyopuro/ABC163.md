---
title: "ABC163の解説"
date: 2020-04-21T16:22:58+09:00
draft: false
---

3完．
unratedで良かった...
[コード](https://github.com/t45k/kyopuro/tree/master/ABC/ABC163)

## A - Circle Pond
やるだけ．<br>
円周は`2 * r * 円周率`．
Javaだと円周率は`java.lang.Math.PI`が使える．

## B - Homework
全ての宿題をやるには`Σ Ai`日かかるので，それを`M`と比較する．

## C - management
問題文が若干ややこしい．
やることは特定の数字が何回出てくるかを数えるだけ．
はじめに配列`array[N + 1]`を用意して，各`Ai`に対して`array[Ai]++`する．

## D - Sum of Large Numbers
時間内に解けなかった．
組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった...<br>
各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない．
あるiに対して`front_sum`を0からi-1までの和，`back_sum`をn-i+1からnまでの和とすると，
i個選択する時の組み合わせによって得られる和は`i * 10^100 + front_sum`から`i * 10^100 + back_sum`までの間に収まる．
つまり，`back_sum - front_sum + 1`通りになる．
`front_sum`と`back_sum`は累積和で取れるので，iをKからNまで動かして足し合わせれば良い．

## E - Active Infants
原始的なDP（ほんまか？）．<br>
活発度が高い順に左か右に移動させる．
活発度を降順にソートした時，`dp[i][j]`を，**(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさ**という風に考える．
そうすると，`dp[i][j]`は**左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させる**か**左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させる**の嬉しさが大きい方になる．
