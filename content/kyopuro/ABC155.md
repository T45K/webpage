---
title: "ABC155の解説"
date: 2020-02-16T22:48:43+09:00
draft: false
---

無念の三冠．

## A問題
重複を調べる問題．<br>
愚直に比較しても良いけど，Setを使うのが早そう．<br>
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．

## B問題
fizzbuzzみたいな問題．<br>
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．

## C問題
連想配列を使って数え上げる典型的な問題．<br>
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくは`Collections.sort()`)．
C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．

## D問題
E問題より難しいD問題．
以下の要素が重なりあってきつい．

### 決め打ち二分探索
決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す．
単調性とは，ある数 `x` に対してその問題が成り立つならば，`x` 以降の数字に対してもなりつような性質を指す．<br>
実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 `isOk(...)` を用意する．
D問題だと**ある値 `x` と `K` が与えられた時に，積が `x` 以下となるペアの個数が `K` 以上の場合は真**のようになる．<br>
次に，二分探索の対象を用意する．このとき，始点は `isOk` が偽となり，かつ終点は真となるような範囲を用意する．
今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので `0 ~ 10^18` のようになる．<br>
そして二分探索する．
二分探索では通常範囲を指定するが，この時始点は `isOk` が偽，終点は真となることを意識する．
通常の二分探索と同じく対象範囲の真ん中の値(`(始点 + 終点) / 2`)をとり，それの真偽を判定する．
真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する．
この操作で，常に始点は偽，終点は真となる．
最終的に始点と終点が連続した値になるため，その終点を解として出力する．<br>
要約すると，`isOk()` を満たす範囲の下界を求める操作だと言える．

### Lower Bound / Upper Bound
Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた．
計算量もそこまで気にする必要はない．
今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある．
そのため，**Lower Bound**や**Upper Bound**を用いる必要がある．<br>
Lower Boundは指定した値**以上**の要素が初めて出現する場所を取得する．<br>
一方，Upper Boundは指定した値**より大きい要素**が初めて出現する場所を取得する．<br>
C++ではこれらが標準ライブラリとして提供されているが，Javaにはない．
Javaでは，`Collections#binarySearch` の第三引数に以下の `Comparator` オブジェクトを渡すことで実現できる．
```java
// 例: List<Long> に対する Comparator
private static final Comparator<Long> lowerBoundComparator = (x, y) -> x >= y ? 1 : -1;
private static final Comparator<Long> upperBoundComparator = (x, y) -> x > y ? 1 : -1;
```
ちなみに，これに限らずJavaの標準ライブラリの `binarySearch` の結果として負の数が帰ってきた場合，bit反転( `~` 演算子)を使うと良い感じになる．

### 負の数の大小比較
今回は負の数の大小を比較したり，負の数の席を求めたりする場面がある．
負の数の大小比較や掛け算は直感と反する場合が多く，考察段階では考えることが増えてしまうことが多い．
そのため，一度負の数を正の数に反転した上で大小比較し，最後に辻褄を合わすようにするのが良い．

## E問題
貪欲にやってもできそうな気がするけど，editorial見て正攻法で解答．<br>
いわゆる桁dpの問題(多分)．
今回は，その桁をちょうど払う状態(以降，**just**)と1多く払う状態(以降，**extra**)に分けて考える．
言い換えると，extraは繰り下がりを考慮した状態といえる．<br>
上の桁から考えていくと，状態遷移は以下のようになる．
- その桁のjust = (前の桁のjust + その桁の数字) か (前の桁のextra + (10 - その桁の数字)) の小さい方
- その桁のextra = (前の桁のjust + その桁の数字 + 1) か (前の桁のextra + (9 - その桁の数字)) の小さい方

これを解いていくと答えになる．<br>
ちなみに，最後の桁は必ずjustとなること，また，最初の桁の前についてもjustとextraを考慮する(99を100で払ったり)ことに注意．

[コード](https://github.com/T45k/kyopuro/tree/master/ABC155)
