---
title: "ABC169の解説"
date: 2020-06-01T13:25:09+09:00
draft: false
---

久々のABC水パフォ．
[コード](https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC169)

## A - Multiplication 1
読み込んで掛け算して出力するだけ．

## B - Multiplication 2
与えられた数字の中に0があれば確定で0．
それ以外の場合，それぞれ掛けて10^18を越えるかを確認すれば良い．
Javaだと`BigInteger`が使える．
比較は`BigInteger#compareTo`で，0より大きければ1が返るっぽい．

## C - Multiplication 3
罠．<br>
Javaだと`BigDecimal`が使える．
解説通りにやるとするなら，一旦文字列で読み込んで，小数点を消した上で整数に変換すると良さそう．

## D - Div Game
まずは素因数分解する．
問題の条件から素数pに対して，p^1，p^2，p^3，...，p^kと割っていくのが最適となる．
したがって，各素数の出現回数からkを求めれば良い．
p^kまで作るには，出現回数は`1+2+3+...k=k(k+1)/2`個必要となる．
これは，kを1から全部列挙して探せば良い．
出現回数の最大値は，N<=10^12≒2^40から高々40回程度なので，全列挙しても十分間に合う．

## E - Count Median
たまたま解けた．<br>
とても単純化してみる．

### Nが奇数の時
N=3で，以下のような時を考える．

```
|---|  |---|  |---|
a   b  c   d  e   f
```

この時，明らかに中央値はc~dの整数値になる．<br>
このことから，何となく中央値は(0-indexedで)前からN/2番目の開始位置と後ろからN/2番目の終了位置の間の整数値であると考えられる．

### Nが偶数の時
N=4で，以下のような時を考える．

```
|---|  |---|  |---|  |---|
a   b  c   d  e   f  g   h
```

この時，中央値は((c~dの値)+(e~fの値))/2となる．
また，片方を1動かせば，中央値は1/2変化するので，中央値は1/2刻みとなる．
中央値候補の最小値は(c+e)/2，最大値は(d+f)/2となるので，その間の1/2刻みの値が中央値になると考えられる．

一般性は，あります！

## F - Knapsack for All Subsets
解説AC．<br>
最初に，dp[N][S]を用意する．
各1<=i<=Nに対して，iを加えるか加えないかの2通りがあるので，iの遷移の度に，dp[i][j]はi-1の各jの値*2となる
そしてAiを加えるかの判定をする．ここは普通のDP
