---
title: "ABC218の解説"
date: 2021-09-13T16:37:09+09:00
draft: false
---

初の 6 完で久々に盛れた．
[コード](https://github.com/T45K/Kyopuro/tree/master/AtCoder/ABC/ABC218)

## A - Weather Forecast

`String#charAt`使う．

## B - qwerty

問題文内では辞書順という言葉を使っているが，単純に`(char)('a' + P_i - 1)`を出力するだけ．

## c - Shapes

アルゴリズムは簡単だが実装が割としんどい問題．

`#`が存在する座標のリストを取得し，それらを左上詰めしたうえで比較する．
例えば，入力例 1 の S

```
.....
..#..
.###.
.....
.....
```

は 0-indexed で`(1,2), (2,1), (2,2), (2,3)`と表せられる．
このとき，行の最小値は 1，列の最小値は 1 なので，
左上詰めするとそれぞれの座標の行，列から 1 ずつ引いて
`(0,1), (1,0), (1,1), (1,2)`と表せられる．

これを S に対して 90° ずつ回転させたリストと T を比較する．

## D - Rectangles

条件から，求めたいのは，
`あるx_iをx座標に持つ点の集合と，あるx_jをx座標に持つ点の集合の間で，y座標が一致する点の集合から2つ選ぶ時の組み合わせの数`になる．
これを実現するため，与えられた点を x 座標をキー，y 座標のリストを値に持つ Map に格納する．
この時，リストは事前にソートしておく．
あとは x 座標の各組合せに対して，一致する y 座標の数を数えておく．
ソートしているので尺取法的に数え上げると，この操作はリストの長さに線形で可能なので十分に間に合う．

## E - Destruction

最小全域木をやるだけ．
C_i が負の辺は問答無用で加えてよい．

## F - Blocked Roads

初めに普通に最短経路を求める（幅優先探索で`O(N+M)`で可能）．
ここで，この最短経路の値を X とすると，最短経路に含まれない辺を通れないとしても，X で頂点 1 から頂点 N に移動できる．
後は，最短経路に含まれる辺それぞれに対して，通れない場合の最短経路をシミュレーションすれば良い．
最短経路に含まれる経路数は高々`N-1`なので十分に間に合う．
