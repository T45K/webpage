---
title: "ABC168の解説"
date: 2020-05-19T19:54:50+09:00
draft: false
---

速解き回だったけど速解き失敗．
4完．
[コード](https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC168)

## A - ∴ (Therefore)
`switch`文を使う問題．
コードが長くなりがち．
Kotlinだと気持ちよく書ける．

```
fun main() {
    Scanner(System.`in`)
        .run {
            when (this.nextInt() % 10) {
                3 -> "bon"
                0, 1, 6, 8 -> "pon"
                else -> "hon"
            }.apply(::println)
        }
}
```

## B - ... (Triple Dots)
やるだけ．
Sの長さがKを上回っているとき，`S.substring(0, K.length)`．

## C - : (Colon)
数学．<br>
極座標か余弦定理を使うと簡単に解ける．
意外と二つの針の間の角度を求めるのが曲者．

## D - .. (Double Dots)
嫌な気持ちになります．<br>
問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．

## E - ∙ (Bullet)
解説AC<br>
解く手順としては
1. 仲の悪いイワシを組み合わせないようにする方法
2. 最終的な組み合わせを数え上げる方法
の2つを考える．

### 1. 仲の悪いイワシを組み合わせないようにする方法
Ai * Aj + Bi * Bj = 0という条件から，美味しさと香り高さがどちらも0のイワシは全てのイワシと仲が悪い．
それ以外のイワシについて考えると，仲が悪くなるにはAi = a, Bi =bの時，Aj = k*b, Bj = -k*aとなる必要がある(kは0以外の整数)．
なのでイワシを2種類のグループに分ける．
1. 美味しさ，香り高さの符号が一致する
2. 美味しさ，香り高さの符号が一致しない

そうすると，それぞれのグループを美味しさと香り高さを互いに素にした値のペアをキー，出現回数をバリューとしたマップにすると，それぞれのキーに対して仲の悪いイワシの数が分かる．
例えば，グループ1のキーを(美味しさの絶対値をGCDで割った値，香り高さの絶対値をGCDで割った値)，グループ2のキーを(香り高さの絶対値をGCDで割った値，美味しさの絶対値をGCDで割った値)にしておくと，グループ1とグループ2の共通するキーが仲の悪い組み合わせになる．

### 2. 最終的な組み合わせを数え上げる方法
まず，全てのイワシが仲が悪くないとき，組み合わせの総数は，どのイワシも選ばない組み合わせを除いて2^N-1になる．
これを踏まえると，先ほどのグループ1，2の各キーに対して，
1. 仲の悪い組み合わがある場合，それぞれのバリューp,qに対して 2^p + 2^q - 1<br>
これはグループ1，2両方のイワシを同時に加えることはできないので別々に計算する．グループ1だけから選ぶ場合は2^p通り，グループ2からだけ選ぶ場合は2^q通りになる．最後に，グループ1，2両方とも選ばない場合が重複しているので1引く．
2. 仲の悪い組み合わせがない場合，そのバリューpに対して 2^p

を掛けていき，最終的に1引いた値（どのイワシも選ばない組み合わせ）が答えになる．
